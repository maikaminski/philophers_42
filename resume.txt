makefile
NAME = philo
CC = cc
FLAGS = -Wall -Werror -Wextra -g
SRC = philo_actions.c philo_close.c philo_init.c philo_main.c \
		philo_monitor.c philo_routine_utils.c philo_routine.c philo_utils.c philo_validate.c
OBJS = $(SRC:%.c=%.o)

all: $(NAME)

	
$(NAME): $(OBJS)
	$(CC) $(FLAGS) -o $(NAME) $(OBJS)
	chmod +x $(NAME) 

%.o: %.c
	$(CC) $(FLAGS) -c $< -o $@

clean:
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re 

philo_actions.c
#include "philo.h"

void	take_forks(t_philo *philo)
{
    if (philo->philo_id % 2 == 0)
    {
    pthread_mutex_lock(philo->right_fork);
    safe_print(philo, FORK);
    pthread_mutex_lock(philo->left_fork);
    safe_print(philo, FORK);
    }
    else
    {
    pthread_mutex_lock(philo->left_fork);
    safe_print(philo, FORK);
    pthread_mutex_lock(philo->right_fork);
    safe_print(philo, FORK);
    }
}

void	release_forks(t_philo *philo)
{
    pthread_mutex_unlock(philo->right_fork);
    pthread_mutex_unlock(philo->left_fork);
}

void	philo_sleep(t_philo *philo)
{
    safe_print(philo, SLEEP);
    usleep(philo->data->time_to_sleep * 1000);
}

void	philo_think(t_philo *philo)
{
    safe_print(philo, THINK);
}

philo_close.c
#include "philo.h"

void	stop_dinner(t_data *data)
{
	int	i;

	i = 0;
	while (i < data->philo_number)
	{
		pthread_join(data->philo[i].thread_id, NULL);
		i++;
	}
}

void	destroy_mutexes(t_data *data)
{
	int	i;

	i = 0;
	while (i < data->philo_number)
	{
		pthread_mutex_destroy(&data->forks[i]);
		i++;
	}
	pthread_mutex_destroy(&data->print);
	pthread_mutex_destroy(&data->lock);
}

void	free_all(t_data *data)
{
	if (data->philo)
		free(data->philo);
	if (data->forks)
		free(data->forks);
}

philo_init.c
#include "philo.h"

int	init_data(t_data *data, int argc, char **argv)
{
	if (validate_args(argc, argv, data))
		return (1);
	data->someone_died = false;
	data->start = 0;
	data->philo = malloc(sizeof(t_philo) * data->philo_number);
	if (!data->philo)
		return (error_msg("Failed to alloc memory for philo.\n"));
	data->forks = malloc(sizeof(pthread_mutex_t) * data->philo_number);
	if (!data->forks)
	{
		free(data->philo);
		return (error_msg("Failed to alloc memory for forks.\n"));
	}
	return (0);
}

void	init_mutex(t_data *data)
{
	int	i;

	i = 0;
	while (i < data->philo_number)
	{
		if (pthread_mutex_init(&data->forks[i], NULL) != 0)
		{
			error_msg("Failed to init fork mutex.\n");
			return ;
		}
		i++;
	}
	if (pthread_mutex_init(&data->print, NULL) != 0)
	{
		error_msg("Failed to init print mutex.\n");
		return ;
	}
	if (pthread_mutex_init(&data->lock, NULL) != 0)
	{
		error_msg("Failed to init lock mutex.\n");
		return ;
	}
}

void	init_philos(t_data *data)
{
	int	i;

	i = 0;
	while (i < data->philo_number)
	{
		data->philo[i].philo_id = i + 1;
		data->philo[i].meals_eaten = 0;
		data->philo[i].last_meal = 0;
		data->philo[i].left_fork = &data->forks[i];
		data->philo[i].right_fork = &data->forks[(i + 1) % data->philo_number];
		data->philo[i].data = data;
		i++;
	}
}

philo_main.c
#include "philo.h"

int	main(int argc, char **argv)
{
	t_data	data;

	if (argc < 5 || argc > 6)
		return (error_msg("Invalid number of arguments\n"));
	if (init_data(&data, argc, argv))
		return (1);
	init_mutex(&data);
	init_philos(&data);
	start_dinner(&data);
	monitor_deaths(&data);
	stop_dinner(&data);
	destroy_mutexes(&data);
	free_all(&data);
	return (0);
}

philo_monitor.c
#include "philo.h"

static int	check_philo_death(t_data *data, int i, uint64_t now)
{
	if (now - data->philo[i].last_meal > data->time_to_dead)
	{
		pthread_mutex_lock(&data->lock);
		data->someone_died = true;
		safe_print(&data->philo[i], DIE);
		pthread_mutex_unlock(&data->lock);
		return (1);
	}
	return (0);
}

static int	check_all_philos(t_data *data, uint64_t now)
{
	int	i;

	i = -1;
	while (++i < data->philo_number)
	{
		if (check_philo_death(data, i, now))
			return (1);
	}
	return (0);
}
void	monitor_deaths(t_data *data)
{
    uint64_t	now;
	uint64_t	last_meal_check;

	last_meal_check = get_time();
	while (!data->someone_died)
	{
		now = get_time();
		if (check_all_philos(data, now))
			return ;
		if (all_full(data))
			return ;
		usleep(1000);
	}
}

bool	all_full(t_data *data)
{
	int	i;
	int	full_count;

	if (data->num_meals == -1)
		return (false);
	full_count = 0; 
	i = 0;
	while (i < data->philo_number)
	{
		pthread_mutex_lock(&data->lock);
		if (data->philo[i].meals_eaten >= data->num_meals)
			full_count++;
		pthread_mutex_unlock(&data->lock);
		i++;
	}
	if (full_count == data->philo_number)
	{
		pthread_mutex_lock(&data->lock);
		data->someone_died = true;
		pthread_mutex_unlock(&data->lock);
		return (true);
	}
	return (false);
}

philo_routine_utils.c
#include "philo.h"

int	should_stop(t_philo *philo)
{
	int	stop;
	
	pthread_mutex_lock(&philo->data->lock);
	stop = philo->data->someone_died;
	pthread_mutex_unlock(&philo->data->lock);
	return (stop);
}

int	is_done_eating(t_philo *philo)
{
	int	done;

	pthread_mutex_lock(&philo->data->lock);
	done = (philo->data->num_meals > 0 && philo->meals_eaten >= philo->data->num_meals);
	pthread_mutex_unlock(&philo->data->lock);
	return (done);
}

void	handle_single_philo(t_philo *philo)
{
	safe_print(philo, FORK);
	usleep(philo->data->time_to_dead * 1000);
}

void	philo_eat(t_philo *philo)
{
	take_forks(philo);
	pthread_mutex_lock(&philo->data->lock);
	philo->last_meal = get_time();
	pthread_mutex_unlock(&philo->data->lock);
	safe_print(philo, EAT);
	usleep(philo->data->time_to_eat * 1000);
	release_forks(philo);
	pthread_mutex_lock(&philo->data->lock);
	philo->meals_eaten++;
	pthread_mutex_unlock(&philo->data->lock);
}

philo_routine.c
#include "philo.h"

void	start_dinner(t_data *data)
{
	int	i;

	data->start = get_time();
	i = 0;
	while (i < data->philo_number)
	{
		data->philo[i].last_meal = data->start;
		if (pthread_create(&data->philo[i].thread_id, NULL, routine, &data->philo[i]) != 0)
			error_msg("Failed to create thread.\n");
		i++;
	}
}

void	*routine(void *arg)
{
	t_philo	*philo;

	philo = (t_philo *)arg;
	if (philo->data->philo_number == 1)
	{
		handle_single_philo(philo);
		return (NULL);
	}
	if (philo->philo_id % 2 == 0)
		usleep(philo->data->time_to_eat * 500);
	while (!should_stop(philo))
	{
		if (!is_done_eating(philo))
		{
			philo_eat(philo);
			philo_sleep(philo);
			philo_think(philo);
		}
		else
			usleep(1000);
	}
	return (NULL);
}

uint64_t	get_time(void)
{
	struct timeval	tv;

	gettimeofday(&tv, NULL);
	return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
}

philo_utils.c
#include "philo.h"

void	safe_print(t_philo *philo, const char *msg)
{
	uint64_t	time;
	int			someone_died;

	pthread_mutex_lock(&philo->data->lock);
	someone_died = philo->data->someone_died;
	pthread_mutex_unlock(&philo->data->lock);
	
	if (!someone_died)
	{
		pthread_mutex_lock(&philo->data->print);
		time = get_time() - philo->data->start;
		printf("%d %s\n", philo->philo_id, msg);
		pthread_mutex_unlock(&philo->data->print);
	}
}

int	error_msg(char *msg)
{
	printf("Error: %s", msg);
	return (1);
}

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
	{
		return (1);
	}
	return (0);
}

int	ft_atol(const char *nbr)
{
	long	i;
	int		isminus;
	long	res;

	i = 0;
	while (nbr[i] == 32 || (nbr[i] >= 9 && nbr[i] <= 13))
		i++;
	isminus = 1;
	if (nbr[i] == '-' || nbr[i] == '+')
	{
		if (nbr[i] == '-')
			isminus *= -1;
		i++;
	}
	res = 0;
	while (nbr[i] >= '0' && nbr[i] <= '9')
	{
		res = res * 10 + (nbr[i] - '0');
		i++;
	}
	return (res * isminus);
}

philo_validate.c
#include "philo.h"

int	is_number(char *str)
{
	int	i;

	i = 0;
	if (!str || !str[0])
		return (0);
	while (str[i])
	{
		if (str[i] < '0' || str[i] > '9')
			return (0);
		i++;
	}
	return (1);
}

int	validate_args(int argc, char **argv, t_data *data)
{
	int	i;

	i = 1;
	while (i < argc)
	{
		if (!is_number(argv[i]))
			return (error_msg("Invalid input: must be a positive number\n"));
		i++;
	}
	data->philo_number = ft_atol(argv[1]);
	data->time_to_dead = ft_atol(argv[2]);
	data->time_to_eat = ft_atol(argv[3]);
	data->time_to_sleep = ft_atol(argv[4]);
	if (argc == 6)
		data->num_meals = ft_atol(argv[5]);
	else
		data->num_meals = -1;
	if (data->philo_number <= 0 || data->time_to_dead <= 0
		|| data->time_to_eat <= 0 || data->time_to_sleep <= 0
		|| (argc == 6 && data->num_meals <= 0))
		return (error_msg("Values must be above 0.\n"));
	return (0);
}

philo.h
#ifndef PHILO_H
# define PHILO_H

# define FORK "has taken a fork"
# define DIE "died"
# define EAT "is eating"
# define SLEEP "is sleeping"
# define THINK "is thinking"

# include <pthread.h>
# include <inttypes.h>
# include <stdio.h>
# include <unistd.h>
# include <stdlib.h>
# include <stdint.h>
# include <sys/time.h>
# include <stdbool.h>
# include <limits.h>

typedef struct s_philo
{
	int				philo_id; // id do philosopho
	int				meals_eaten; //contador de refeições
	uint64_t		last_meal; // tempo de quando foi a ultima refeição
	pthread_t		thread_id;	// id da thread
	pthread_mutex_t	*left_fork;
	pthread_mutex_t	*right_fork;
	struct s_data	*data;
}	t_philo;

typedef struct s_data
{
	int					philo_number; //numero de philosophos
	int					num_meals; // número de refeições (caso seja passado como parametro)
	uint64_t			time_to_sleep;
	uint64_t			time_to_eat;
	uint64_t			time_to_think;
	uint64_t			time_to_dead;
	uint64_t			start; //quando começa
	bool				someone_died;
	pthread_mutex_t		*forks; // trava o garfo
	pthread_mutex_t		print; // trava o write
	pthread_mutex_t		lock; // controle de morte
	struct s_philo		*philo;
}	t_data;

// Philo actions
void	take_forks(t_philo *philo);
void	release_forks(t_philo *philo);
void	philo_sleep(t_philo *philo);
void	philo_think(t_philo *philo);

// Philo close
void	stop_dinner(t_data *data);
void	destroy_mutexes(t_data *data);
void	free_all(t_data *data);

// Philo init
int	init_data(t_data *data, int argc, char **argv);
void	init_mutex(t_data *data);
void	init_philos(t_data *data);

//Philo monitor
void	monitor_deaths(t_data *data);
bool	all_full(t_data *data);

// Philo routine utils

int	should_stop(t_philo *philo);
int	is_done_eating(t_philo *philo);
void	handle_single_philo(t_philo *philo);
void	philo_eat(t_philo *philo);

// Philo routine
void	start_dinner(t_data *data);
void	*routine(void *arg);
uint64_t	get_time(void);

// Philo utils
void	safe_print(t_philo *philo, const char *msg);
int	error_msg(char *msg);
int	ft_isdigit(int c);
int	ft_atol(const char *nbr);

// Philo validate
int	is_number(char *str);
int	validate_args(int argc, char **argv, t_data *data);

#endif